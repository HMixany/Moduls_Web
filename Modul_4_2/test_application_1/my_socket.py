import socket


# sock = socket.socket()

# серверна частина
# sock.bind(('', 9090))
'''
Для початку скажемо системі, на якому порту та адресі прийматимемо з'єднання. Якщо залишити аргумент для адреси порожнім 
рядком,то сокет буде доступним для всіх інтерфейсів. Порт ми вказали 9090.
Тепер у нас все готове, щоб приймати з'єднання. За допомогою методу listen ми запустимо для цього сокету режим 
прослуховування. Метод приймає один аргумент — максимальна кількість підключень у черзі
'''
# sock.listen(1)
'''
Тепер ми можемо прийняти підключення за допомогою методу accept, який повертає кортеж із двома елементами: новий сокет 
та адреса клієнта. Саме цей сокет і буде використовуватися для приймання та відправлення даних клієнту.
'''
# conn, addr = sock.accept()
'''
Тепер ми встановили зв'язок з клієнтом і можемо з ним «спілкуватися». Ми не можемо точно знати, що і в яких обсягах 
клієнт нам надішле, тому ми будемо отримувати дані від нього невеликими порціями. Щоб отримати дані, потрібно 
скористатися методом recv, який як аргумент приймає кількість байт для читання. Ми читатимемо порціями по 1024 байт 
(або 1 кб):
'''
# while True:
#     data = conn.recv(1024)
#     if not data:
#         break
#     conn.send(data.upper())
'''
Ми в нескінченному циклі приймаємо 1024 байт даних за допомогою методу recv. Якщо даних більше немає, цей метод нічого 
не повертає. Таким чином, ми можемо отримувати від клієнта будь-яку кількість даних.
Далі у нашому прикладі для наочності ми щось зробимо з отриманими даними та відправимо їх назад клієнту. Наприклад, 
за допомогою методу upper у рядків повернемо клієнту рядок у верхньому регістрі.
Тепер можна і закрити з'єднання
'''
# conn.close()
'''
Сокет — це системний ресурс і, як і файл, його потрібно повернути системі (закрити), що б не сталося. Для цього, як і у 
файлів, ми можемо скористатися менеджером контексту. Ми також можемо закривати з'єднання за допомогою менеджера контексту, 
щоб гарантовано не залишати його відкритим, навіть у разі помилки.

Крім цього, ще корисно вказати системі, що якщо застосунок не закрив з'єднання, то потрібно дозволити повторно відкрити 
тому самому порту. Для цього налаштуємо сокет
'''
# sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)


# Об'єднаємо все в одну функцію
def echo_server(host, port):
    with socket.socket() as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((host, port))
        s.listen(1)
        conn, addr = s.accept()
        print(f"Connected by {addr}")
        with conn:
            while True:
                data = conn.recv(1024)
                print(f'From client: {data}')
                if not data:
                    break
                conn.send(data.upper())
# Тепер функція echo_server створює сервер, який завжди очікує з'єднання

# Клієнтська частина
'''
Клієнтський застосунок простіший — нам потрібно створити сокет, підключитися до сервера, надіслати йому дані, прийняти 
дані та закрити з'єднання
'''
from time import sleep


def simple_client(host, port):
    with socket.socket() as s:
        while True:
            try:
                s.connect((host, port))
                s.sendall(b'Hello, world')
                data = s.recv(1024)
                print(f'From server: {data}')
                break
            except ConnectionRefusedError:
                sleep(0.5)
'''
Єдине нове тут – це метод connect, за допомогою якого ми підключаємось до сервера. З'єднання може не встановлюватися з 
першого разу. Щоб обробити помилку з'єднання, ми помістили клієнтський код у нескінченний цикл для повторення спроб 
з'єднатися
'''
# Клієнт-серверний застосунок на потоках
'''
Тепер об'єднаємо клієнтський та серверний застосунок в один і запустимо їх у різних потоках
'''
import threading


HOST = '127.0.0.1'
PORT = 55555

server = threading.Thread(target=echo_server, args=(HOST, PORT))
client = threading.Thread(target=simple_client, args=(HOST, PORT))

server.start()
client.start()
server.join()
client.join()
print('Done!')
'''
Операції із сокетами — за замовчуванням блокуючі. Це означає, що виклики connect, accept, recv, sendall не дадуть 
застосунку продовжувати роботу, доки не завершаться успішно. Але цю поведінку можна змінити. Якщо ви, наприклад, хочете 
перевіряти, чи не підключився новий клієнт, і робити ще щось корисне в цьому ж потоці. У такому разі виклик accept відразу 
поверне виняток і не буде очікувати на підключення. Для цього можна встановити прапорець
'''
socket.setblocking(0)
"""
Асинхронні сокети asyncio реалізовані саме за допомогою обробки результатів неблокуючих викликів при socket.setblocking(0)
"""
